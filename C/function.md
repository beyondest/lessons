
### **指针传递是按值传递**

在 C 中，传递指针给函数时是**按值传递**的，这意味着 `a` 在 `a` 函数中的值（指针）是 `main` 中 `b` 的一个副本。当你在 `a` 函数内改变 `a` 的指向时，实际上改变的是 `a` 的局部副本，而不是 `main` 中 `b` 的值。换句话说，`b` 在 `main` 中的值没有发生变化。

### **原因解析**

```c
void a(int* a)
{
    a = (int*)malloc(sizeof(int)); // 给局部变量 a 分配内存
    *a = 10; // 为局部变量 a 指向的内存赋值
    printf("a = %d\n", *a); // 输出 10
}
```

在 `a` 函数中，`a` 是一个局部指针变量，它指向传入的 `b` 的值（也就是 `NULL`）。当你执行 `a = (int*)malloc(sizeof(int));` 时，你修改的是 `a` 指向的内存，给它分配了新的内存地址，而这个修改并不会影响 `main` 中的 `b`。因此，`b` 在 `main` 中依然是 `NULL`。

---

### **`main` 中的情况**

```c
int* b = NULL;
a(b);  // 传递给 a 的是 b 的副本
printf("b = %d\n", *b); // 这里会出现未定义行为，因为 b 依然是 NULL
```

在 `main` 中，`b` 仍然是 `NULL`，所以当你尝试解引用 `b`（`*b`）时，会导致**未定义行为**，通常这会引发程序崩溃（如段错误，segmentation fault）。

### **解决方法**

如果你希望在 `a` 函数中修改 `b` 指向的内存，你需要传递指向指针的指针（即 `int**`），这样你就可以修改 `b` 在 `main` 中的值。

### **修改后的代码**

```c
#include <stdio.h>
#include <stdlib.h>

void a(int** a)
{
    *a = (int*)malloc(sizeof(int)); // 分配内存给 *a
    **a = 10;  // 修改 *a 指向的内存
    printf("a = %d\n", **a);  // 输出 10
}

int main()
{
    int* b = NULL;
    a(&b);  // 传递 b 的地址
    printf("b = %d\n", *b);  // 输出 10
    free(b);  // 记得释放内存
    return 0;
}
```

### **关键变化**：

- 在 `a` 函数中，参数类型改为 `int** a`，这样你可以通过 `*a` 修改 `b` 的指向。
- 在 `main` 函数中，传递 `b` 的地址给 `a`（`a(&b)`），这样 `a` 函数可以修改 `b`，让它指向分配的内存。

### **输出**：

```
a = 10
b = 10
```

这样，`b` 在 `main` 中就指向了新分配的内存，并且你可以正确地访问它。