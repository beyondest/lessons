# Difference in all print method and scan method in C language

在 C 语言中，`printf` 是最常用的打印函数，用于将格式化输出写入标准输出（通常是控制台）。然而，`printf` 家族中还有其他类似的函数（如 `printf_s` 和其他变种），它们在功能和用途上有些细微的差别。以下是主要的打印函数及其区别：

---

### **1. `printf`**
#### **功能**
- 用于格式化输出，写入标准输出流（`stdout`）。
- 最常用，兼容性好，几乎在所有 C 编译器和平台上都可以使用。

#### **语法**
```c
int printf(const char *format, ...);
```
- **`format`**：格式化字符串。
- **返回值**：成功时返回写入的字符数；出错时返回负值。

#### **特点**
- 不提供内置安全检查（如缓冲区溢出或参数错误）。
- 需要确保提供的参数数量和类型与格式化字符串匹配，否则可能导致未定义行为。

#### **示例**
```c
printf("Hello, %s! You have %d new messages.\n", "Alice", 3);
```

---

### **2. `printf_s`**
#### **功能**
- 是 C11 标准引入的“安全”函数，用于增强代码的安全性。
- 提供了一些附加的运行时检查，例如格式字符串和参数的合法性。

#### **语法**
```c
int printf_s(const char *format, ...);
```

#### **特点**
- 如果检查失败，程序行为是未定义的（可能会终止）。
- 在大多数实现中，`printf_s` 和 `printf` 的功能几乎一致，但只有在启用了运行时安全检查的环境中才有差异。
- 并不总是可用，尤其是在非 C11 环境中。

#### **适用场景**
- 如果项目使用了 C11 标准，并且需要更严格的安全约束，可以使用 `printf_s`。
- 在很多编译器中（如 GCC），`printf_s` 可能未实现。

---

### **3. `fprintf`**
#### **功能**
- 类似于 `printf`，但允许将输出写入指定的文件流。

#### **语法**
```c
int fprintf(FILE *stream, const char *format, ...);
```
- **`stream`**：输出流（如文件指针 `FILE *`）。
- **返回值**：成功时返回写入的字符数；失败时返回负值。

#### **适用场景**
- 当需要将格式化输出重定向到文件或其他流时使用。

#### **示例**
```c
FILE *file = fopen("output.txt", "w");
if (file) {
    fprintf(file, "Log: %s\n", "This is a message.");
    fclose(file);
}
```

---

### **4. `sprintf` 和 `snprintf`**
#### **功能**
- **`sprintf`**：将格式化字符串写入一个字符数组。
- **`snprintf`**：与 `sprintf` 类似，但提供缓冲区大小限制，防止缓冲区溢出。

#### **语法**
```c
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);
```

#### **区别**
- **`sprintf`**：不检查缓冲区大小，容易导致缓冲区溢出。
- **`snprintf`**：更安全，因为输出会被限制在指定的大小范围内。

#### **示例**
```c
char buffer[100];
sprintf(buffer, "Hello, %s!", "Alice");  // 不安全
snprintf(buffer, sizeof(buffer), "Hello, %s!", "Alice"); // 安全
```

---

### **5. `puts` 和 `putchar`**
#### **功能**
- **`puts`**：输出字符串并自动追加换行符。
- **`putchar`**：输出单个字符。

#### **语法**
```c
int puts(const char *str);
int putchar(int c);
```

#### **适用场景**
- 简单的字符串或字符输出，不需要格式化。

#### **示例**
```c
puts("Hello, world!");
putchar('A');
```

---

### **常用函数对比**

| 函数名        | 功能                                    | 是否安全  | 常用场景                  |
|---------------|-----------------------------------------|-----------|---------------------------|
| `printf`      | 标准格式化输出                         | 否        | 控制台打印，最常用         |
| `printf_s`    | 带运行时检查的格式化输出（C11）         | 是        | 需要额外安全约束的项目     |
| `fprintf`     | 将输出定向到指定文件流                 | 否        | 打印日志到文件             |
| `sprintf`     | 将格式化字符串写入数组                 | 否        | 格式化字符串，不推荐       |
| `snprintf`    | 带缓冲区大小限制的字符串格式化         | 是        | 安全的字符串格式化         |
| `puts`        | 输出字符串，自动加换行                 | 是        | 简单字符串输出             |
| `putchar`     | 输出单个字符                           | 是        | 简单字符输出               |

---

### **推荐使用**
1. **标准输出：** 优先使用 `printf` 或 `snprintf`（如果需要格式化到缓冲区）。
2. **安全性：** 如果需要额外的安全约束，可以使用 `snprintf` 或 `printf_s`。
3. **文件输出：** 使用 `fprintf`。

---

### **注意事项**
- 在现代 C 编程中，推荐优先使用安全版本（如 `snprintf` 和 `fopen_s`），特别是在开发需要高安全性的软件时。
- 如果项目中需要兼容性，通常仍以 `printf` 为主，因为它是最广泛支持的。



你在 Visual Studio 中遇到的报错是因为微软的 C 运行库 (CRT) 默认将某些函数（如 `scanf`）标记为“不安全”，以鼓励开发者使用更安全的版本（如 `scanf_s`）。以下是解决方法、各个函数的区别以及用法的详细说明。

---

## **Scanf Error In Visual Studio**
微软将 `scanf` 等标准库函数标记为“可能不安全”，因为它们无法有效防止缓冲区溢出等潜在问题。例如，当用户输入的内容超出目标缓冲区大小时，可能导致程序崩溃或其他未定义行为。

---

## **各个 `scan` 函数的区别**

### **1. `scanf`**
- 标准 C 中的格式化输入函数。
- 无法自动检查目标缓冲区的大小，使用不当可能引发安全问题。
- 支持各种数据类型的输入。

**用法：**
```c
char name[10];
scanf("%s", name); // 无法限制输入长度，可能导致缓冲区溢出
```

---

### **2. `scanf_s`**
- 是微软扩展的安全版本（非标准）。
- 增加了运行时检查，用于某些数据类型（如字符串和数组），需要额外提供缓冲区大小作为参数。

**用法：**
```c
char name[10];
scanf_s("%9s", name, (unsigned)_countof(name)); // 提供缓冲区大小
```

**区别：**
- 额外的参数指定缓冲区大小，防止输入超出范围。
- 仅在 Visual Studio 或支持 Microsoft CRT 的环境中可用。

---

### **3. `_CRT_SECURE_NO_WARNINGS`**
- 如果你仍希望使用 `scanf` 而不修改代码，可以通过定义 `_CRT_SECURE_NO_WARNINGS` 来关闭这些警告。
- **注意：** 关闭警告并不解决潜在的安全问题，仅适用于受信任的代码。

**实现方法：**
- 在源代码文件的开头添加：
  ```c
  #define _CRT_SECURE_NO_WARNINGS
  ```

- 或者在项目设置中添加：
  1. 右键项目 > 属性。
  2. 转到 **C/C++ > 预处理器 > 预处理器定义**。
  3. 添加 `_CRT_SECURE_NO_WARNINGS`。

---

### **4. `sscanf` 和 `sscanf_s`**
- **`sscanf`**：从字符串中读取格式化输入，类似于 `scanf`。
- **`sscanf_s`**：是 `sscanf` 的安全版本，需要缓冲区大小参数。

**用法：**
```c
char input[] = "12345";
int value;
sscanf(input, "%d", &value); // 标准用法

char name[10];
sscanf_s(input, "%9s", name, (unsigned)_countof(name)); // 安全用法
```

---

### **如何选择和处理**

#### **1. 优先使用安全版本 (`scanf_s`)**
如果你在 Visual Studio 中开发，并希望遵循微软推荐的安全实践，应使用 `scanf_s` 替代 `scanf`。需要注意为缓冲区数据类型（如字符串）提供长度参数。

#### **2. 如果需要兼容性，关闭警告**
在编写跨平台代码或需要兼容 C 标准的情况下，可以继续使用标准 `scanf`，并通过 `_CRT_SECURE_NO_WARNINGS` 禁用警告。

#### **3. 推荐替代方案**
在现代 C 编程中，尽量避免直接使用 `scanf` 或 `scanf_s`，可以考虑以下替代方案：
- 使用 `fgets` 读取字符串，避免缓冲区溢出：
  ```c
  char buffer[100];
  if (fgets(buffer, sizeof(buffer), stdin)) {
      sscanf(buffer, "%d", &value); // 从缓冲区解析输入
  }
  ```
- 使用 C++ 的输入流（`std::cin`），更安全且更灵活（适用于 C++ 项目）。

---

### **总结**

#### **各函数对比**

| 函数名      | 标准/扩展 | 是否安全 | 适用场景                        |
|-------------|-----------|----------|---------------------------------|
| `scanf`     | 标准      | 否       | 快速开发，兼容 C 标准            |
| `scanf_s`   | 扩展      | 是       | 安全性优先，推荐在 Visual Studio 使用 |
| `_CRT_SECURE_NO_WARNINGS` | N/A | N/A      | 禁用警告，不推荐用于生产环境      |
| `fgets` + `sscanf` | 标准      | 是       | 安全替代方案，推荐读取字符串      |

根据项目需求：
- **如果你在学习或编写小型程序，直接使用 `scanf` 并禁用警告。**
- **如果是安全性要求高的项目（尤其是企业级代码），推荐使用 `scanf_s` 或 `fgets` 等更安全的方式处理输入。**